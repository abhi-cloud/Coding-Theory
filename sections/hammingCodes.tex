\documentclass[../main.tex]{subfiles}

\begin{document}

The Hamming codes, defined in this section, are an importtant family of single-error-correcting codes, which are easier to to encode and decode than other similar codes.\\
These codes are best defined using their parity-check matrix:

\begin{defn}
	Let $r$ be a positive integer and let $H$ be an $r\times (2^r - 1)$ matrix whose columns are the distinct non-zero vectors of $V(r,2)$. Then the code having $H$ as its parity-check matrix is called a \textbf{\emph{binary Hamming code}} and is denoted by Ham$(r,2)$.\\
\end{defn}

\begin{remark}
	\begin{enumerate*}[label=(\roman*), before=\unskip{}]
		\item Ham$(r,2)$ has length $n=2^r-1$ and dimension $k = n-r$. $r$ is also called the \textbf{\emph{redundancy}} of the code.\\
		\item Ham$(r,2)$ is the code generated by any of the matrix $H$, since its colums can be taken in any order.
	\end{enumerate*}
\end{remark}

\begin{thm}
	The binary Hamming code Ham$(r,2)$, for $r\geq 2$,
	\begin{enumerate}[label=(\roman*)]
	\itemsep-1mm
		\item is a $[2^r-1, 2^r-1-r]$-code;
		\item has a minimum distance 3 (therefore, single-error correcting);
		\item is a perfect code.
	\end{enumerate}
\end{thm}

\begin{proof}
	$\;$ 
	\begin{enumerate}[label=(\roman*)]
	\itemsep-1mm
		\item By definition, Ham$(r,2)^\perp$ is a $[2^r-1,r]$-code ans so Ham$(r,2	)$ is a $[2^r-1, 2^r-1-r]$-code.
		\item Since, Ham$(r,2)$ is a linear code, it is enough, by Theoem \ref{thm_minwt_is_mindist}, to show that every non-zero codeword has weight$\geq 3$.\\
		Firstly, suppose that the code has codeword $\code{x}$ of weight 1, with non-zero element at $i$th position, but as it is orthogonal to every row in $H$, this implies that the $i$th column of $H$ is the all-zero vector, contradicting the definition of $H$.\\
		Similarly, if codeword $\code{x} \in$ Ham$(r,2)$, where 
		\[
			\code{x} = 0\cdots 010\cdots 010\cdots 0
		\]
		with $1$s in the $i$th and $j$th places. Let $H = \{h_{pq}\}$ then since \code{x} is orthogonal to each row of $H$, this implies
		\[
			h_{si} = h_{sj} \hspace{2mm}(\text{mod} 2)\hspace{4mm} \forall\; s \in \{1,2,\ldots,r\}
		\]  
		 Hence the $i$th and $j$th columns of $H$ are identical, again contradicting the definition.
		 Thus $d$(Ham$(r,2)$) $\geq 3$, and it is easy to see that the equality exists, for example vector $11100\cdots 0$ can exist in Ham$(r,2)$, by a suitable rearrangement of columns in $H$.
		 \item The left-hand side of shere packing bound is
		 \[
		 	2^{n-r}\left(1 + \binom{n}{1}\right) = 2^{n-r}(1+n) = 2^n
		 \]  
		 Therefore, the bound is acheived and the code is a perfect code.
	\end{enumerate}	
	
\end{proof}

As a binary Hamming code is a perfect code, the coset leaders are precisely the $2^r$ vectors of $V(n,2)$ of weight $\leq 1$. Now if we arrange the columns of $H$ in order of increasing binary numbers, we can have the following nice \textbf{decoding algorithm}. We calculate the syndrome $S(\code{y})$ of the received vector \code{y} as usual, if it is $\code{0}$, then assume it was the codeword sent, otherwise assume single error and the value of $S(\code{y})$ gives the position of the error, as the syndromes are the columns of $H$ itself.

\begin{defn}
	The \textbf{\emph{extended binary Hamming code}} H\^{a}m$(r,2)$ is the code obtained from Ham$(r,2)$ by adding an overall parity-check.
\end{defn}
It can be proven by above results that H\^{a}m$(r,2)$ is a $[2^r, 2^r-1-r,4]$-code. It is of no better than Ham$(r,2)$ when used for complete decoding, but can be used for incomplete decoding, for it can simultaneously correct any single error and detect any double error.\\

\begin{center}
\line(1,0){250}
\end{center}

Now we shall define Hamming codes over arbitrary field $GF(q)$, before that we need to understand the following relationship between minimum distance of a linear code and linear inidependence property between columns of parity-check matrix.

\begin{thm}\label{thm_parity_n_mindiff}
	Suppose $C$ is a linear $[n,k]$-code over $GF(q)$ with parity-check matrix $H$. Then the minimum distance of $C$ is $d$ if and only if any $d-1$ columns of $H$ are linearly independent but some $d$ columns are linearly dependent.
\end{thm}

\begin{proof}
	By Theoem \ref{thm_minwt_is_mindist}, the minimum distance of $C$ is equal to the smallest of weights of the non-zero codewords. Let $\code{x} = x_1x_2\cdots x_n$ be a vector in $V(n,q)$. Then 
	\begin{align*}
		\code{x} \in C &\Longleftrightarrow \code{x}H^T = 0 \\
		&\Longleftrightarrow x_1\code{H}_1 + x_2\code{H}_2 + \cdots + x_n\code{H}_n = \code{0}
	\end{align*}
	where $\code{H}_i$ denote the columns of H.\\
	Therefore, for each codeword \code{x} of weight $d$, there is a set of $d$ linearly dependent columns of $H$. On the other hand, if there existed some $d-1$ dependent columns of $H$, then we would have a codeword, defined by coefficients (not all zero) of those $d-1$ columns, with coeffients being the value of codeword's $i$th position (where $i$ belongs ti $d-1$ column positions in $H$), and 0 at other places. Thus, this codeword will have weight $< d$, hence contradiction.  
\end{proof}
\vspace{2mm}
Now, any non-zero vector $\code{v}$ in $V(r,q)$ has exactly $q-1$ non-zero scalar multiples, forming set $\{\lambda \code{v} | \lambda \in GF(q), \lambda \neq 0\}$. Hence, $q^r-1$ non-zero vectors of $V(r,q)$ may be partitioned into $(q^r-1)/(q-1)$ vectors, where each set consists of elements that are scalar multiples of other elements of that set. Now by choosing one vector from each set of $(q^r-1)/(q-1)$ vectors, no two of which are linearly dependent. Therfore, by theorem \ref{thm_parity_n_mindiff}, taking these as the columns of $H$ gives a parity-check matrix of a $\left[\frac{(q^r-1)}{q-1}, \frac{q^r-1}{q-1}-r,3\right]$-code. This is called \textbf{\textit{$q$-ary Hamming code}} and is denoted by Ham$(r,q)$.\\
Here also, Ham$(r,q)$ is unique upto equivalence.\\

\textbf{Example}: A parity-check matrix for Ham$(2,11)$ is
\[	
	\left[
	\begin{array}{cccccccccccc}
		0 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1 & 1  \\
		1 & 0 & 1 & 2 & 3 & 4 & 5 & 6 & 7 & 8 & 9 & 10 \\
	\end{array}
	\right]
\]

\begin{thm}
	Ham$(r,q)$ is a perfect single-error-correcting code.
\end{thm}
\begin{proof}
	Ham$(r,q)$ was constructed to be an $(n,M,3)$-code with $n=(q^r-1)/(q-1)$ and $M=q^{n-r}$. The left-hand side of the sphere-packing bound becomes 
	\begin{align}
		q^{n-r}(1 + n(q-1)) &= q^{n-r}(1 + q^r -1)\\
		&= q^n
	\end{align}
	which is the right-hand side, so Ham$(r,q)$ is a perfect code.	 
\end{proof}

\begin{cor}
	If $q$ is a prime power and if $n=(q^r-1)/(q-1)$, for some $r \geq 2$, then
	\[
		A_q(n,3) = q^{n-r}
	\]
\end{cor}
\vspace{2mm}

\textbf{Decoding with a q-ary Hamming code}:\\
Since a Hamming code is a perfect single-error correcting code, the codet leaders, other than $\code{0}$, are precisely the vectors of weight $1$. The syndrome of such a coset leader $code{x} = 0\cdots 0b0\cdots 0$, with non-zero element at the $j$th place, is
\[
	S(\code{x}) = b\code{H}_j^T,
\]
where $\code{H}_j$ denotes the $j$th column of $H$.\\
So the decoding scheme is as follows. If the received vector is \code{y}, then first calculate the syndrome $S(\code{y})$, if $S(\code{y})=\code{0}$, assume no errors, otherwise $S(\code{y}) = b\code{H}_j^T$ for some $b$ and $j$ and the assumed single error is corrected by subtracting $b$ from the $j$th entry of $\code{y}$.

\end{document}